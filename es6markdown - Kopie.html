<!DOCTYPE html>
<html>
	<head>
		<title>Title</title>
		<meta charset="utf-8">
		<style>
     			@import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
           		@import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
	        	@import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
	        	body { font-family: 'Droid Serif'; }
			h1, h2, h3 { font-family: 'Yanone Kaffeesatz';
				     font-weight: normal; }
			.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
		</style>
	</head>
	<body>
		<textarea id="source">

			

# ECMAScript2015

---

# Agenda

- Was ist ECMAScript2015
- Let and const
- default parameter
- destructuring
- rest parameter and spread operator
- promises
- super strings
- arrays
- classes
- arrow functions
- modules
- enhanced object literals
- iterator
- map/set
- proxying
- internationalization and localization
- things to avoid
- can I use it/where can I use it

---

# arrow function
Arrows

Arrows are a function shorthand using the => syntax. They are syntactically similar to the related feature in C#, Java 8 and CoffeeScript. They support both statement block bodies as well as expression bodies which return the value of the expression. Unlike functions, arrows share the same lexical this as their surrounding code.
```js
// Expression bodies
var odds = evens.map(v => v + 1);
var nums = evens.map((v, i) => v + i);
var pairs = evens.map(v => ({even: v, odd: v + 1}));

// Statement bodies
nums.forEach(v => {
  if (v % 5 === 0)
    fives.push(v);
});

// Lexical this
var bob = {
  _name: "Bob",
  _friends: [],
  printFriends() {
    this._friends.forEach(f =>
      console.log(this._name + " knows " + f));
  }
}
```

---

# modules
Language-level support for modules for component definition. Codifies patterns from popular JavaScript module loaders (AMD, CommonJS). Runtime behaviour defined by a host-defined default loader. Implicitly async model – no code executes until requested modules are available and processed.

```js
// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;

// app.js
import * as math from "lib/math";
alert("2p = " + math.sum(math.pi, math.pi));

// otherApp.js
import {sum, pi} from "lib/math";
alert("2p = " + sum(pi, pi));

Some additional features include export default and export *:

// lib/mathplusplus.js
export * from "lib/math";
export var e = 2.71828182846;
export default function(x) {
    return Math.log(x);
}

// app.js
import ln, {pi, e} from "lib/mathplusplus";
alert("2p = " + ln(e)*pi*2);
```

---

# enhanced object literals
Object literals are extended to support setting the prototype at construction, shorthand for foo: foo assignments, defining methods, making super calls, and computing property names with expressions. Together, these also bring object literals and class declarations closer together, and let object-based design benefit from some of the same conveniences.
```js
var obj = {
    // __proto__
    __proto__: theProtoObj,
    // Shorthand for ‘handler: handler’
    handler,
    // Methods
    toString() {
     // Super calls
     return "d " + super.toString();
    },
    // Computed (dynamic) property names
    [ 'prop_' + (() => 42)() ]: 42
};
```
---
# iterator
A more concise syntax has been introduced for iteration through arrays and other iterable objects.
```js
var arr = ['a', 'b', 'c'];

// ES5
for (var i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

// ES6
for (let i of arr) {
    console.log(i);
}
```
---
# Sets & Maps
Efficient data structures for common algorithms. WeakMaps provides leak-free object-key’d side tables.
```js
// Sets
var s = new Set();
s.add("hello").add("goodbye").add("hello");
s.size === 2;
s.has("hello") === true;

// Maps
var m = new Map();
m.set("hello", 42);
m.set(s, 34);
m.get(s) == 34;

// Weak Maps
var wm = new WeakMap();
wm.set(s, { extra: 42 });
wm.size === undefined

// Weak Sets
var ws = new WeakSet();
ws.add({ data: 42 });
// Because the added object has no other references, it will not be held in the set
```
---
# proxying
There are 3 key terms we need to define before we proceed:
1. handler: the placeholder object which contains the trap(s)
2. traps: the method(s) that provide property access
3. target: object which the proxy virtualizes

Code Example:
```js
var target = {};
var handler = {
  get: function (receiver, name) {
    return `Hello, ${name}!`;
  }
};
var p = new Proxy(target, handler);
p.world === 'Hello, world!';
```

There are many real-world applications for Proxies:
1. validation
2. value correction
3. property lookup extensions
4. tracing property accesses
5. revocable references
6. implementing the DOM in javascript
---

# internationalization and localization
ToDo

---
# Verwendbarkeit
Symbols, generators, iterators, weak maps and sets, and proxies are genuinely useful but they aren't supported by every browser yet.

		</textarea>
		<script src="https://remarkjs.com/downloads/remark-latest.min.js">
    		</script>
        	<script>
		
     			 var slideshow = remark.create();
          	</script>

	</body>
</html>

