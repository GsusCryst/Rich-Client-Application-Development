<!DOCTYPE html>
<html>
<head>
<title>Title</title>
<meta charset="utf-8">
<style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 { font-family: 'Yanone Kaffeesatz';
                     font-weight: normal; }
        .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class: middle, center

# Softwarequalit√§ts-Tooling

---
	
# Agenda

    1.0 Testing Functional JavaScript
        1.1 Why Test?
        1.2 Why Functional?
        1.3 How pure Functions work
        1.4 What makes Functional Code easy to test?
        1.5 Testing Functional JavaScript
        1.6 Refactoring a pure Function
    2.0 Test NodeJS using Mocha, Chai, SinonJS
        2.1 Literature on Tools
            2.1.1 Mocha
            2.1.2 Chai
            2.1.3 SinonJS
        2.2 Spies, Stubs, Mocks
        2.3 Testing Async Code
            2.3.1 Callbacks
            2.3.2 Promises
    3.0 Snapshot Testing React with Jest
        3.1 What is a Snapshot Test?
        3.2 Introducing Jest
        3.3 Setting Up Snapshot Testing
        3.4 Add a Snapshot Test
        3.5 Failed Snapshot Tests
        3.6 Updating Snapshot Tests
        3.7 Create a New Component with Tests
    4.0 Links

---

class: middle, center

# 1.0 Testing Functional JavaScript

---

### 1.1 Why Test?

- making sure that the code in the application does what is expected and keeps doing what is expected when it gets changed
- tests define an expected functionality under a defined set of circumstances
- there will be a warning until the code gets fixed
- tests in a nutshell:
    - Unit tests validate the functionality of isolated code
    - Integration tests verify the flow of data and the interaction of components
    - Functional tests look at the behaviour of the overall application
- tests can be written at any point in the coding process, but it is more efficient to write unit tests before writing the function
- this practice is known as <a href="https://www.sitepoint.com/learning-javascript-test-driven-development-by-example/" target="_blank">test-driven development(TDD)</a>
 
---

### 1.2 Why Functional?

- functional programming allows to deal with the data and the behaviour of the application independently
- the application is build by creating a set of independent functions that work in isolation and don't rely on external state
- the result:
    - the code becomes almost self-documenting
    - tied clearly defined functions behave in consistent and understandable ways
- functional programming is often contrasted against imperative programming and object-oriented programming
- JavaScript can support all of these techniques and even mix-and-match them
- functional programming can be a worthwhile alternative to:
    - creating sequences of imperative code that track the state of the application across multiple steps until a result is returned
    - building an application out of interactions across complex objects that encapsulate the methods that apply to a specific data structure

---

### 1.3 How pure Functions work

- functional programming encourages to build an application out of tiny, reusable, composable functions that do a specific task and return the same value for the same input
- a function like this is called **pure function**:
    - doesn't rely on external state or variables
    - doesn't cause side effect or alter external variables
    - always return the same result for the same input
- another advantage: makes it easier to do unit testing
- therefore the code can be refactored without breaking essential functionality

---

layout: true

### 1.4 What makes Functional Code easy to test?

---

- writing tests for a pure function is trivial because every single input has a consistent output
- all that has to be done is setting the expectations and run them against the code
- no context needs to be established
- no inter-functional dependencies to keep track of
- no changing state outside of the function that needs to be simulated
- no variable external data sources to be mocked out
- there are a lot of testing options ranging from full-fledged frameworks to utility libraries and simple testing harnesses
- these include <a href="https://jasmine.github.io/" target="_blank">Jasmine</a>, <a href="https://mochajs.org/" target="_blank">Mocha</a>, <a href="http://airbnb.io/enzyme/" target="_blank">Enzyme</a>, <a href="https://facebook.github.io/jest/" target="_blank">Jest</a>, etc.
- each one has different advantages and disadvantages and best use cases

---

#### Jasmine

- Jasmine is a robust framework that can be used in a wide variety of circumstances
- create a HTML document that pulls the testing library locally/from CDN
```HTML
<head>
    <meta charset="utf-8">
    <title>Jasmine Test</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jasmine/
        2.6.1/jasmine.min.css">
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/
        2.6.1/jasmine.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/
        2.6.1/jasmine-html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/
        2.6.1/boot.min.js"></script>
</body>
```
- brings in the Jasmine library, along with Jasmine HTML boot script and styling

---

layout: true

### 1.5 Testing Functional JavaScript - The first Test

---

- this can be done in a separate document or by including it inside a **script tag** element on the page
- use the <a href="https://jasmine.github.io/api/2.6/global.html#describe" target="_blank">describe</a> function defined by the Jasmine library to describe the behaviour for a new function
- the example function to write will be called **isPalindrome** and will return **true** if the string passed is the same forward and backwards otherwise **false**
```js
describe("isPalindrome", () => {
        it("returns true if the string is palindrome", () => {
            expect(isPalindrome("abba")).toEqual(true);
        });
        it("returns false if the string isn't a palindrome", () => {
            expect(isPalindrome("Bubba")).toEqual(false);
        });
});
```
- add this to a script in the page and load it

---

- a working Jasmine report page will show up: <a href="testJasmineFail.html" target="_blank">click</a>

- this is the result that was expected because there is no function **isPalindrome**
- adding the **isPalindrome** function
```js
const isPalindrome = (str) => {
    return str
            .split("")
            .reverse()
            .join("") === str;
};
```
- results in: <a href="testJasmineSuccess.html" target="_blank">click</a>
- this code is a pure function

---

layout: true

### 1.6 Refactoring a pure Function

---

- at this point it is trivial to add additional functionality, such as handling non-string input, ignoring difference between upper and lower case, etc.
- add a test for a number (1001): <a href="testJasmineFail2.html" target="_blank">click</a>
```js
it("returns true if a number is a palindrome", () => {
        expect(isPalindrome(1001)).toEqual(true);
});
```
- update the script to handle non-string inputs and coercing them into strings: <a href="testJasmineSuccess2.html" target="_blank">click</a>
```js
return str
        .toString()
        .split("")
        .reverse()
        .join("") === str.toString();
```

---

layout: false
class: middle, center

# 2.0 Test NodeJS using Mocha, Chai, SinonJS

---

layout: true

### 2.1.1 Literature of Tools - Mocha

---

- Mocha is a test runner, runs/executes tests
- install Mocha
```shell
> npm install -g mocha
```
- create new directory for the application
```shell
> mkdir testing-async-code && cd testing-async-code
> npm init
> npm install --save mocha
> mkdir tests
```
- add a basic test to see how Mocha works
```js
const assert = require("assert");
    describe("smoke test", function() {
        it("checks equality", function() {
            assert.equal(true, true);
        });
});
```

---

- to run this run the command **mocha** and pass the directory of the tests
```shell
> mocha tests/
```
- the tests passed: <a href="" target="_blank">click</a>
- to let the test fail, adjust the file
```js
const assert = require("assert");
    describe("smoke test", function() {
        it("checks equality", function() {
            assert.equal(true, false);
        });
});
```
- the tests stop: <a href="" target="_blank">click</a>

---

layout: false

### 2.1.2 Literature of Tools - Chai

- Chai is a assertion library
- install
```bash
> npm i --save-dev chai
```
- change the smoke test to
```js
const chai = require("chai");
const expect = chai.expect;
describe("smoke test", function() {
        it("checks equality", function() {
            expect(true).to.be.true;
        });
});
```

---

### 2.1.3 Literature of Tools - SinonJS

- SinonJS provides stand alone test spies, stubs and mocks
- install
```bash
> npm i --save-dev sinon
```
- Spies:
    - creates fake functions which can be used to track executions (also for existing functions)
    - tracks if the function has been executed/how many times its been called etc.
- Stubs:
    - enables the replacement of functions
    - gives more control
    - can return what ever is needed
    - have functions work in a way that suites to be able to test multiple scenarios
- Mocks:
    - fake methods that have pre-programmed behaviour and expectations

---

layout: true

### 2.2 **Spies**, Stubs, Mocks

---

- create a new file in your project folder: /controllers/app.controller.js to use Spies, Stubs and Mocks


- example function for the endpoint
```js
module.exports = {
// A func that takes in two parameters `req` and `res` [request, response]
        getIndexPage: (req, res) => {
            res.send("Hey");
        }
}
```
- to test this a function that takes two parameters is required

---

- create a new file inside the tests folder: /tests/controllers/app.controller.tests.js
```js
const chai = require("chai");
const expect = chai.expect;
// import the getIndexPage function
const indexPage = require("../../controllers/app.controller.js");
describe("getIndexPage", function() {
        it("should return index page", function() {
            let req = {}
// res has a send key with a function value because res.send() in function
            let res = {
                send: function() {}
            }
            indexPage.getIndexPage(req, res)
        });
});
```
- this doesn't give anything to test or much control over the function
- use a spy and make some assertions on the spy

---

- making assertions on a spy is possible because the spy gives a dummy function that can be used to track the functions execution
```js
[...]
const expect = chai.expect;
// import sinon
*const sinon = require("sinon");
const indexPage = require("../../controllers/app.controller.js");
[...]
        let req = {}
        let res = {
 *      send: sinon.spy()
        }
        indexPage.getIndexPage(req, res);
        // let's see what we get on res.send
 *   console.log(res.send);
[...]
```
- now a test can be run with the **mocha** command
- a list of all methods that can be used to make assertions for the tests is returned by **res.send**

---

---

layout: true

### 2.2 Spies, **Stubs**, Mocks

---

layout: true

### 2.2 Spies, Stubs, **Mocks**

---

layout: true

### 2.3.1 Testing Async Code - Callbacks

---

layout: true

### 2.3.2 Testing Async Code - Promises

---

layout: false
class: middle, center

# 3.0 Snapshot Testing React with Jest

---

layout: true

### 3.1 What is a Snapshot Test?

---

layout: true

### 3.2 Introducing Jest

---

layout: true

### 3.3 Setting Up Snapshot Testing

---

layout: true

### 3.4 Add a Snapshot Test

---

layout: true

### 3.5 Failed Snapshot Tests

---

layout: true

### 3.6 Updating Snapshot Tests

---

layout: true

### 3.7 Create a New Component with Tests

---

layout: false

# 4.0 Links

- Testing Functional JavaScript

https://www.sitepoint.com/testing-functional-javascript/
- Test NodeJS using Mocha, Chai, SinonJS

https://scotch.io/tutorials/how-to-test-nodejs-apps-using-mocha-chai-and-sinonjs
- Snapshot Testing React with Jest

https://daveceddia.com/snapshot-testing-react-with-jest/

---

layout: true

# Inhalt

---

## Inhalt - Subthema

---

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
         var slideshow = remark.create({
            highlightLines: true
        });
</script>

</body>
</html>

