<!DOCTYPE html>
<html>
<head>
<title>Title</title>
<meta charset="utf-8">
<style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 { font-family: 'Yanone Kaffeesatz';
                     font-weight: normal; }
        .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
</style>
</head>
<body>
<textarea id="source">

class:center, middle

# npm and Webpack4

---

layout: true

# Agenda

---

1. npm
2. webpack4

---

## 1. npm

1. What is npm?
2. Installing Node.js
3. Changing the Location of Global Packages
4. Installing Packages in Global Mode
5. Listing Global Packages
6. Installing Packages in Local Mode
7. Managing Dependencies with package.json
8. Uninstalling Local Packages
9. Installing a Specific Version of a Package
10. Updating a Package
11. Searching for Packages
12. Re-installing Project Dependencies
13. Managing the Cache
14. Aliases
15. Version Managers
16. Links

---

layout: true

# What is npm?

---

## Node Package Manager

- Node.js is used to create tools to aid local task automation
- to make use of these Node-based tools(such as Grunt, Gulp, Webpack) the Node package manager(npm) was created
- it installs the packages(Tools) and provides a useful interface
- npm can install packages in local or global mode
- in local mode it installs in node_modules folder in your parent working directory
- this location is owned by the current user
- in global mode it installs in {prefix}/lib/node_modules/ which is owned by root
- on macOs/Linux you need sudo to install packages globally
- this could cause permission errors: [How to change this](#changing)

---

layout: true

# Installing Node.js

---

- <a href="https://nodejs.org/en/download/">download</a> Node.js for Windows/macOS/Linux
- for Linux, Node can be installed via package manager
- check for the path and version of Node.js:

```shell
$ which node //Windows 'where node'
/usr/bin/node //Windows 'C:\...\node.exe'
$ node --version
v8.11.1
```

- to verify the installation use Node's REPL(Read-Eval-Print-Loop):

```shell
$ node
> console.log('Node is running');
Node is running
> .help
.break Sometimes you get stuck, this gets you out
.clear Alias for .break
.exit  Exit the repl
.help  Show repl options
.load  Load JS from a file into the REPL session
.save  Save all evaluated commands in this REPL session to a file
> .exit
```

---

- check for the path and version of npm:

```shell
$ which npm // Windows 'where npm'
/usr/bin/npm // Windows 'C:\npm' and 'C:\npm.cmd'
$ npm --version
5.6.0
```

---

layout: true

# Changing the Location of Global Packages

---

name: changing

- let's see what output **npm config** gives us

```shell
$ npm config list
; cli configs
user-agent = "npm/3.10.10 node/v6.10.3 linux x64"

; userconfig /home/sitepoint/.npmrc
prefix = "/home/sitepoint/.node_modules_global"

; node bin location = /usr/bin/nodejs
; cwd = /home/sitepoint
; HOME = /home/sitepoint
; "npm config ls -l" to show all defaults.
```

- this gives us information about the install
- get the current global location

```shell
$ npm config get prefix
/usr //Windows 'C:\...\AppData\Roaming\npm'
```

- this is the prefix to change, to install global packages in home directory

---

- to do that create a new directory in your home folder

```shell
$ cd ~ && mkdir .node_modules_global //Windows 'cd .'
$ npm config set prefix=$HOME/.node_modules_global 
//Windows 'prefix=C:\...\.node_modules_global'
```

- the location to which global Node packages are installed has been altered
- this also creates a **.npmrc** file in the home directory

```shell
$ npm config get prefix
/home/sitepoint/.node_modules_global //Windows 'C:\...\.node_modules_global'
$ cat .npmrc //Windows 'type .npmrc'
prefix=/home/sitepoint/.node_modules_global 
//Windows 'prefix=C:\...\.node_modules_global'
```

- install npm again, but in the new user-owned location

```shell
$ npm install npm --global
└─┬ npm@6.0.0
  ├── abbrev@1.1.0
....
└── write-file-atomic@2.1.0
```

---

- finally add **.node_modules_global/bin** to the **$PATH** environment variable
- for Linux/macOS add the following to **.profile**, **.bash** or **.bashrc** file and restart the terminal

```shell
export PATH="$HOME/.node_modules_global/bin:$PATH"
```

- for Windows write the following in the command line

```shell
setx path "C:\...\.node_modules_global\bin;%PATH%"
```

- now **.node_modules_global/bin** will be found first and the correct version of npm will be used

```shell
$ which npm //Windows 'where npm'
/home/sitepoint/.node_modules_global/bin/npm 
//Windows 'C:\...\.node_modules_global\bin\npm'
$ npm --version
6.0.0
```

---

## 2. webpack4

1. What is webpack4?
2. setup using boilerplate
3. Modules
4. Loaders
5. Code Splitting
6. Plugins
7. Development
8. Links

---

layout: true

# Inhalt

---

## Inhalt - Subthema

---

layout: false

# What is webpack4?

Webpack has become one of the most important tools for modern web development.

It’s primarily a module bundler for your JavaScript, but it can be taught to transform all of your front-end assets like HTML, CSS, even images.

It can give you more control over the number of HTTP requests your app is making and allows you to use other flavors of those assets (Pug, Sass, and ES8, for example).

Webpack also allows you to easily consume packages from npm.

---

layout: false

# setup using boilerplate

The fastest way to start a react.js application is to use a boilerplate:

1. Make sure you have the latest Stable or LTS version of Node.js installed.
2. Clone this repo using: "git clone --depth=1 https://github.com/react-boilerplate/react-boilerplate.git".
3. Move to the appropriate directory: "cd react-boilerplate".
4. Run "npm run setup" in order to install dependencies and clean the git repo.
5. Run "npm start" to see the example app at "http://localhost:3000".
6. Run "npm run clean" to delete the example app.

---

layout: false

# Modules

Modules can split up your large programs into many small, self-contained programs using import and export statements.

```js
const people = [
  {
    manager: "Jen",
    name: "Bob"
  },
...
]
export default people
```

```js
import people from "./people"
```
---
# Loaders
Loaders let you run preprocessors on files as they’re imported. This allows you to bundle static resources beyond JavaScript.


Babel Example:
```npm
npm install --save-dev "babel-loader@^8.0.0-beta" @babel/core @babel/preset-env
```

webpack.config.js
```js
...
   module: {
     rules: [
       {
         test: /\.js$/,
         exclude: /(node_modules|bower_components)/,
         use: {
           loader: 'babel-loader',
         }
       }
     ]
...
```
---
# Loaders
This config prevents Babel from transpiling import and export statements into ES5. We’re now free to use modern language features, and they’ll be compiled down to ES5 that runs in all browsers.

.babelrc

```js
{
  "presets": [
    ["@babel/env", {
      "modules": false
    }]
  ],
  "plugins": ["syntax-dynamic-import"]
}
```
---
# Code Splitting

Code Splitting allows you to split your code into various bundles which can then be loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, can have a major impact on load time.

webpack.config.js
```js
const path = require('path');
const HTMLWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: {
    index: './src/index.js'
  },
  plugins: [
    new HTMLWebpackPlugin({
      title: 'Code Splitting'
    })
  ],
  output: {
    filename: '[name].bundle.js',
    chunkFilename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};
```
---
# Code Splitting
As import() returns a promise, it can be used with async functions.

This requires using Babel with Syntax Dynamic Import Plugin:

index.js
```js
async function getComponent() {
  var element = document.createElement('div');
  const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');
  element.innerHTML = _.join(['Hello', 'webpack'], ' ');
  return element;
}
getComponent().then(component => {
  document.body.appendChild(component);
});
```
---
# Plugins
Plugins are here to help us split our code in clever ways and optimize things for production.

Standard Modes:
+ development
+ production (default)

config
```js
module.exports = {
  mode: 'production'
};
```

```cli
webpack --mode=production
```
---
# Development
The webpack-dev-server provides you with a simple web server and gives you live reloading, so you don’t need to manually refresh the page to see changes.

The HotModuleReplacement plugin goes one step further than Live Reloading and swaps out modules at runtime without the refresh. When configured correctly, this saves a huge amount of time during development of single page apps. Where you have a lot of state in the page, you can make incremental changes to components, and only the changed modules are replaced and updated.

---
# Development
## HotModuleReplacement plugin
webpack.dev.js
```js
* const webpack = require('webpack')
  const merge = require('webpack-merge')
  const common = require('./webpack.common.js')

  module.exports = merge(common, {
    mode: 'development',
*   devServer: {
*     hot: true
*   },
*   plugins: [
*     new webpack.HotModuleReplacementPlugin()
*   ],
    ...
```
app.js
```js
if (module.hot) {
  module.hot.accept()
}
```
---

# Links
+ https://www.reactboilerplate.com/
+ https://babeljs.io/docs/plugins/syntax-dynamic-import/#installation
+ https://webpack.js.org/guides/code-splitting/
+ https://www.sitepoint.com/beginners-guide-webpack-module-bundling/
+ https://webpack.js.org/concepts/mode/#usage
+ https://medium.com/webpack/webpack-http-2-7083ec3f3ce6

</textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js">
</script>
<script>
         var slideshow = remark.create();
</script>

</body>
</html>

